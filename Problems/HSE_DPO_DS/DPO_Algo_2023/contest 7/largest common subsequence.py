# https://contest.yandex.ru/contest/50168/problems/P/
# Общей подпоследовательностью двух строк s1 и s2 называется пара последовательностей индексов ({ai},{bi}) такая,
# что a1 < a2 < … < ak, b1 < b2 < … < bk, and s1[ai]=s2[bi] for all 1≤ i≤ k.
# Найдите наибольшую общую подпоследовательность двух строк. Первая и вторая строки входа содержат две непустые строки,
# каждая из которых состоит из строчных латинских букв. Длина каждой строки не превосходит 100. В первой строке выведите
# целое число k — длину наибольшей общей подпоследовательности. Во второй выведите k целых чисел — индексы символов
# наибольшей общей подпоследовательности в первой строке, отсортированные по возрастанию. В третьей, аналогично —
# отсортированные по возрастанию индексы символов наибольшей общей подпоследовательности во второй строке. Символы в
# строках занумерованы с 1.
# Если способов выбрать наибольшую общую подпоследовательность несколько, выведите любой из них.

def answer(s1, s2):
    n, m = len(s1), len(s2)
    dp = [[0] * (m + 1) for _ in range(n + 1)]

    for i, c1 in enumerate(s1, 1):
        for j, c2 in enumerate(s2, 1):
            if c1 == c2:
                dp[i][j] = dp[i - 1][j - 1] + 1
            else:
                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])

    i, j = n, m
    index_i = []
    index_j = []

    while i > 0 and j > 0:
        if s1[i - 1] == s2[j - 1]:
            index_i.append(i)
            index_j.append(j)
            i -= 1
            j -= 1
        elif dp[i - 1][j] == dp[i][j]:
            i -= 1
        else:
            j -= 1

    return dp[-1][-1], index_i[::-1], index_j[::-1]


def test0():
    test_data = (('abcd', 'cxbydz'), )
    for s1, s2 in test_data:
        print(*answer(s1, s2), sep='\n')


if __name__ == '__main__':
    tests = (test0, )
    for test in tests:
        test()
