# https://contest.yandex.ru/contest/49987/problems/C/
# Алгоритм Флойда-Уоршелла.
#
# Дан полный ориентированный взвешенный граф задан матрицей смежности. Постройте матрицу кратчайших путей между его
# вершинами. Гарантируется, что в графе нет циклов отрицательного веса.
#
# В первой строке вводится единственное число N (1 ≤ N ≤ 100) – количество вершин графа. В следующих N строках по N
# чисел задается матрица смежности графа (j-ое число в i-ой строке соответствует весу ребра из вершины i в вершину j).
# Все числа по модулю не превышают 100. На главной диагонали матрицы – всегда нули.

def get_all_shortest_paths(adj_m, n):
    for k in range(n):
        for i in range(n):
            for j in range(n):
                adj_m[i][j] = min(adj_m[i][j], adj_m[i][k] + adj_m[k][j])


def test0():
    test_data = ([[0, 100, 1, 100, 100, 100], [1, 0, 100, 4, 2, 100], [100, 100, 0, 1, 100, 100],
                  [100, 4, 100, 0, 100, 6], [100, 1, 100, 100, 0, 4], [1, 100, 100, 100, 100, 0]], )
    for adj_m in test_data:
        n = len(adj_m[0])
        result = [adj_m[i].copy() for i in range(n)]
        get_all_shortest_paths(result, n)
        for i in range(n):
            print(*result[i])


if __name__ == '__main__':
    tests = (test0, )
    for test in tests:
        test()
