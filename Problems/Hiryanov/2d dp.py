# пример двумерных динпрог задач
# из лекции Хирьянова https://www.youtube.com/watch?v=m4HOkVeN4Mo

# шахматный король живет на доске NxM и может совершать
# ходы: вправо на 1 и вниз на 1.
# сколько разных способов есть у короля чтобы добраться
# из клетки (1,1) в клетку (N,M).
# Пусть K_{i,j} - кол-во способов достичь клетки (i,j)
# Тогда K_{i,j} = K_{i-1,j} + K_{i,j-1}


def king_traj_count(N, M):
    # создаем таблицу N+1 строк на M+1 столбцов
    # дополнительные строка и столбец нужны для
    # удобства (барьерные элементы)
    # F_{i,j} = F[i][j]

    F = [[0]*(M+1) for i in range(N+1)]

    #F_{1,1} = 1 по условию
    F[1][1] = 1
    
    #заполняем таблицу F
    for i in range (1,N+1):
        for j in range (1,M+1):
            #элемент F_{1,1} не вычисляем 
            if i == 1 and j == 1:
                continue

            F[i][j] = F[i][j-1] + F[i-1][j]

    return F,F[-1][-1]

#наибольшая общая подпоследовательность.
#пусть A,B - одномерные массивы чисел 
#длины N и M соответственно
#пусть F_{i,j} - длина наибольшей возможной подпоследовательности
#частей A и B: A[0:i] - часть А из первых его i элементов и
#B[0:j] - аналогичная часть B.
#F_{i,j} = F_{i-1,j-1} + 1, если  A[i-1]==B[j-1]
#        = max(F_{i,j-1},F_{i-1,j}) если A[i-1]!=B[j-1]
#
#F_{0,j} = F_{i,0} = 0  для всех i,j

def lcs(A,B):
    N = len(A)+1
    M = len(B)+1
    F = [[0]*M for i in range(N)]

    for i in range(1,N):
        for j in range(1,M):
            if A[i-1] == B[j-1]:
                F[i][j] = F[i-1][j-1] + 1
            else:
                F[i][j] = max(F[i][j-1],F[i-1][j])

    return F[-1][-1]

#наибольшая возрастающая подпоследовательность
#1й подход: свести к предыдущей задаче: lcs(A,sorted(A)) - 
#тогда O(N^2) сложность по времени O(N^2) - сложность по памяти, где  N = len(A)
#но так можно сделать, только если речь идет о неубывающей подпоследовательности. 
#Если ищется строго возрастающая подпоследовательность, то такой подход не сработает.

#2й подход
#заметим, что для самого короткого среза А[0:i], в котором лежит искомая НВП, 
#верно, что А[i-1] (последний элемент среза) принадлежит НВП и является 
#максимальным элементом НВП.
#Поэтому пусть F_i -  длина НВП для среза A[0:i] 
#при этом это такая НВП, которая заканчивается и содержит A[i-1].
#Тогда F_i = max(F_j)+1 при j<i и A[i-1]>A[j-1], либо 0 если условия не выполнены.
#Длина искомой НВП в таком случае будет max(F)

def gis(A):
    N = len(A)+1
    F = [0]*N
    M = 0
    for i in range(1,N):
        m = 0
        for j in range(1,i):
            if F[j]>m and A[i-1]>A[j-1]:
                m=F[j]
        F[i] = m + 1
        if F[i]>M:
            M=F[i]

    return M

def test0():
    print(king_traj_count(3,5))

def test1():
    print(lcs([0,0,1,0,0,0,5,0,0,0,6,6,6,6,6],[1,2,3,5,6,6,6,6,6,6,6,6,6,6]))

def test2():
    A = [-1,10,7,3,4,5,100,200,1,2,3,4,5,6,7,8,9,10,]
    print(lcs(A,sorted(A)))
    print(gis(A))

if __name__ == '__main__':
    test2()


    